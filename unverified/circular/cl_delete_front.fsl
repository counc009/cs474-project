(Function next Loc Loc)
(Function key  Loc Int)

(RecFunction Lseg Loc Loc Bool)
(RecFunction Circ Loc Bool)
(RecFunction CKys Loc Loc SetInt)
(RecFunction Keys Loc SetInt)

(Var x Loc)
(Var y Loc)

(RecDef (Lseg x y) (ite (= x y) True
                   (ite (= x nil) False
                        (and (Lseg (next x) y)
                             (not (IsMember x (Sp (Lseg (antiSp (next x)) y)))) ))))
(RecDef (Circ x) (ite (= x nil) True
                 (and (Lseg (next x) x)
                      (not (IsMember x (Sp (Lseg (antiSp (next x)) (antiSp x))))) )))

(RecDef (CKys x y) (ite (= x y) EmptySetInt
                        (SetAdd (CKys (next x) y) (key x))))
(RecDef (Keys x) (ite (= x nil) EmptySetInt
                      (SetAdd (CKys (next x) x) (key x))))

(lemma (x y) (=> (Lseg x y) (= (Sp (Lseg x y)) (Sp (CKys x y)))))

(Var k Int)
(Var tmp Loc)
(Var ret Loc)
(Var oldkeys SetInt)

(Program find_end (x y ret))
(Pre (and (Lseg x y) (not (= x nil)) (not (= y nil)) (not (= x y)) ))
(Post (and (Lseg x y) (= (CKys x y) (Old (CKys x y)))
           (Lseg x ret) (= (next ret) y)
           (IsMember ret (Sp (Lseg x y))) ))

(If (= (next x) y)
 Then
  (assign ret x)
  (return)
 Else
  (assign tmp (next x))
  (call find_end (tmp y ret))
  (return)
)

(Program cl_delete_front (x ret))
(Pre (and (Circ x)
      (ite (= x nil) (= oldkeys EmptySetInt) (= oldkeys (CKys (next x) x))) ))
(Post (and (Circ ret) (= (Keys ret) oldkeys) ))

(If (= x nil)
 Then
  (assign ret x)
  (return)
 Else (If (= (next x) x)
 Then
  (free x)
  (assign ret nil)
  (return)
 Else
  (assign ret (next x))
  (call find_end (x ret tmp))
  (assign (next tmp) ret)
  (free x)
  (return)
))

/* BB 5 fails to verify because of some issue with free */
/* Not sure about BB 6 */
