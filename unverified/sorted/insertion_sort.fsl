(Var x Loc)
(Var k Int)

(Function next Loc Loc)
(Function key  Loc Int)

(Var plus_infty Int)
(RecFunction Min Loc Int)
(RecDef (Min x) (ite (= x nil) plus_infty (ite (< (key x) (Min (next x))) (key x) (Min (next x)))))

(RecFunction Keys   Loc SetInt)
(RecFunction Sorted Loc Bool)
(RecFunction List   Loc Bool)

(RecDef (Keys x) (ite (= x nil) EmptySetInt
                 (SetAdd (Keys (next x)) (key x))))
(RecDef (Sorted x) (ite (= x nil) True
                      (and (Sorted (next x))
                           (not (IsMember x (Sp (Sorted (antiSp (next x))))))
                           (<= (key x) (Min (next x))))))
(RecDef (List x) (ite (= x nil) True
                      (and (List (next x))
                           (not (IsMember x (Sp (List (antiSp (next x)))))))))

(lemma (x) (< (key x) plus_infty))
(lemma (x) (=> (Sorted x) (= (SPKeys x) (SPSorted x))))
(lemma (x) (=> (Sorted x) (= (Sp (List x)) (Sp (Sorted x)))))
(lemma (x) (=> (List x) (= (Sp (Keys x)) (Sp (List x)))))

(Var l1 Loc)
(Var l2 Loc)
(lemma (l1 l2) (=> (= (Keys l1) (SetAdd (Keys l2) k))
                   (ite (< k (Min l2)) (= (Min l1) k) (= (Min l1) (Min l2)))))

(Var y Loc)
(Var ret Loc)
(Var nxt Loc)
(Var tmp Loc)

(Program sorted_insert (x y k ret))
(Pre (and (Sorted x) (= k (key y)) (not (IsMember y (Sp (Sorted x)))) ))
(Post (and (Sorted ret) (= (Keys ret) (SetAdd (Old (Keys x)) k))
           (= (next ret) (next ret)) ))

(If (= x nil)
 Then
  (assign (next y) nil)
  (assign ret y)
  (return)
 Else (If (> k (key x))
 Then
  (assign nxt (next x))
  (call sorted_insert (nxt y k tmp))
  (assign (next x) tmp)
  (assign ret x)
  (return)
 Else
  (assign (next y) x)
  (assign ret y)
  (return)
))

(Program insertion_sort (x ret))
(Pre (List x))
(Post (and (Sorted ret) (= (Keys ret) (Old (Keys x))) ))

(If (= x nil)
 Then
  (assign ret x)
  (return)
 Else
  (assign nxt (next x))
  (call insertion_sort (nxt tmp))
  (assign k (key x))
  (call sorted_insert (tmp x k ret))
  (return)
)
