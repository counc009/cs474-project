(Function key   Loc Int)
(Function prio  Loc Int)
(Function left  Loc Loc)
(Function right Loc Loc)

(RecFunction MinKey  Loc Int)
(RecFunction MaxKey  Loc Int)
(RecFunction MaxPrio Loc Int)

(RecFunction Treap      Loc Bool)
(RecFunction Keys       Loc SetInt)
(RecFunction Priorities Loc SetInt)

(Var x Loc)
(Var plus_infty Int)
(Var minus_infty Int)

(lemma (x) (< (key x) plus_infty))
(lemma (x) (< minus_infty (key x)))
(lemma (x) (< minus_infty (prio x)))

(RecDef (MinKey x)
  (ite (= x nil) plus_infty
    (ite (<= (key x) (MinKey (left x)))
      (ite (<= (key x) (MinKey (right x)))
        (key x)
        (MinKey (right x))
      )
      (ite (<= (MinKey (left x)) (MinKey (right x)))
        (MinKey (left x))
        (MinKey (right x))))))

(RecDef (MaxKey x)
  (ite (= x nil) minus_infty
    (ite (>= (key x) (MaxKey (left x)))
      (ite (>= (key x) (MaxKey (right x)))
        (key x)
        (MaxKey (right x))
      )
      (ite (>= (MaxKey (left x)) (MaxKey (right x)))
        (MaxKey (left x))
        (MaxKey (right x))))))
(RecDef (MaxPrio x)
  (ite (= x nil) minus_infty
    (ite (>= (prio x) (MaxPrio (left x)))
      (ite (>= (prio x) (MaxPrio (right x)))
        (prio x)
        (MaxPrio (right x))
      )
      (ite (>= (MaxPrio (left x)) (MaxPrio (right x)))
        (MaxPrio (left x))
        (MaxPrio (right x))))))

(RecDef (Treap x)
  (ite (= x nil) True
    (and (Treap (left x))  (< (MaxKey (left x)) (key x))  (< (MaxPrio (left x)) (prio x))
         (Treap (right x)) (< (key x) (MinKey (right x))) (< (MaxPrio (right x)) (prio x))
         (= EmptySetInt (SetIntersect (Priorities (left x)) (Priorities (right x))))
         (not (IsMember x (Sp (Treap (antiSp (left x))))))
         (not (IsMember x (Sp (Treap (antiSp (right x))))))
         (= EmptySetLoc (SetIntersect (Sp (Treap (antiSp (left x))))
                                      (Sp (Treap (antiSp (right x))))))
         )))

(RecDef (Keys x)
  (ite (= x nil) EmptySetInt
    (SetAdd (SetUnion (Keys (left x)) (Keys (right x))) (key x))))
(RecDef (Priorities x)
  (ite (= x nil) EmptySetInt
    (SetAdd (SetUnion (Priorities (left x)) (Priorities (right x))) (prio x))))

(Var k Int)
(Var p Int)
(Var ret Loc)
(Var rht Loc)
(Var lft Loc)
(Var tmp Loc)

(Var right_left Loc)
(Var right_right Loc)
(Var left_left Loc)
(Var left_right Loc)

(Var xl Loc)
(Var xr Loc)

(lemma (x) (=> (Treap x) (= (Sp (Treap x)) (Sp (Keys x)))))
(lemma (x) (=> (Treap x) (= (Sp (Treap x)) (Sp (Priorities x)))))
(lemma (x) (=> (Treap x) (= (Sp (Treap x)) (Sp (MinKey x)))))
(lemma (x) (=> (Treap x) (= (Sp (Treap x)) (Sp (MaxKey x)))))
(lemma (x) (=> (Treap x) (= (Sp (Treap x)) (Sp (MaxPrio x)))))

(lemma (x) (=> (< k (MinKey x)) (not (IsMember k (Keys x)))))
(lemma (x) (=> (> k (MaxKey x)) (not (IsMember k (Keys x)))))

(lemma (x) (=> (not (= x nil))
               (= (SetUnion (Keys (left x)) (Keys (right x)))
                  (SetDel (Keys x) (key x)))))
(lemma (x) (=> (not (= x nil))
               (= (SetUnion (Priorities (left x)) (Priorities (right x)))
                  (SetDel (Priorities x) (prio x)))))

(Var t1 Loc)
(Var t2 Loc)
(lemma (t1 t2) (=> (= (Keys t1) (SetDel (Keys t2) k))
                   (>= (MinKey t1) (MinKey t2))))
(lemma (t1 t2) (=> (= (Keys t1) (SetDel (Keys t2) k))
                   (<= (MaxKey t1) (MaxKey t2))))
(lemma (t1 t2) (=> (IsSubset (Priorities t1) (Priorities t2))
                   (<= (MaxPrio t1) (MaxPrio t2))))

(Program treap_remove_root (x k p ret))
(Pre (and (not (= x nil)) (Treap x) (= (key x) k) (= (prio x) p) ))
(Post (and (Treap ret) (= (Keys ret) (SetDel (Old (Keys x)) k))
           (= (Priorities ret) (SetDel (Old (Priorities x)) p)) ))

(If (and (= (left x) nil) (= (right x) nil))
 Then
  (free x)
  (assign ret nil)
  (return)
 Else (If (= (left x) nil)
 Then
  (assign ret (right x))
  (free x)
  (return)
 Else (If (= (right x) nil)
 Then
  (assign ret (left x))
  (free x)
  (return)
 Else
  (assign rht (right x))
  (assign lft (left x))

  (If (<= (prio lft) (prio rht))
   Then
    (assign right_left (left rht))
    (assign (right x) right_left)
    (call treap_remove_root (x k p tmp))
    (assign (left rht) tmp)
    (assign ret rht)
    (return)
   Else
    (assign left_right (right lft))
    (assign (left x) left_right)
    (call treap_remove_root (x k p tmp))
    (assign (right lft) tmp)
    (assign ret lft)
    (return)
  )
)))

(Program treap_delete (x k ret))
(Pre (Treap x))
(Post (and (Treap ret) (= (Keys ret) (SetDel (Old (Keys x)) k))
           (IsSubset (Priorities ret) (Old (Priorities x)))
           (ite True True (= (left ret) (left ret)))
           (ite True True (= (right ret) (right ret))) ))

(If (= x nil)
 Then
  (assign ret x)
  (return)
 Else (If (= (key x) k)
 Then
  (assign p (prio x))
  (call treap_remove_root (x k p ret))
  (return)
 Else (If (< k (key x))
 Then
  (assign xl (left x))
  (call treap_delete (xl k tmp))
  (assign (left x) tmp)
  (assign ret x)
  (return)
 Else
  (assign xr (right x))
  (call treap_delete (xr k tmp))
  (assign (right x) tmp)
  (assign ret x)
  (return)
)))

/* BB 2 & 3 fail because of free and Old seeming to have issues 
 * BB 5 & 7 run for over 5 minutes without a result
 * BB 12 & 14 run for over 15 minutes
 */
